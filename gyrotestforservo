import smbus
import math
import time
import RPi.GPIO as GPIO
import os

# Register Addresses
power_mgmt_1 = 0x6b
power_mgmt_2 = 0x6c

# Setup for Servo Control (Using GPIO 12 for PWM and GPIO 13 for PWM)
GPIO.setmode(GPIO.BOARD)
SERVO1_PIN = 12  # GPIO pin for Servo 1 (X-axis) - Physical Pin 16 (GPIO 12 supports PWM)
SERVO2_PIN = 13  # GPIO pin for Servo 2 (Y-axis) - Physical Pin 33 (GPIO 13 supports PWM)
GPIO.setup(SERVO1_PIN, GPIO.OUT)
GPIO.setup(SERVO2_PIN, GPIO.OUT)

# Set up PWM for the servos
servo1 = GPIO.PWM(SERVO1_PIN, 50)  # 50Hz for standard servos (GPIO 12 supports PWM)
servo2 = GPIO.PWM(SERVO2_PIN, 50)  # 50Hz for standard servos (GPIO 13 supports PWM)

# Start servos at neutral position (7.5%)
servo1.start(7.5)
servo2.start(7.5)  

# Setup for I2C Communication
bus = smbus.SMBus(1)
address = 0x68  # Default I2C address for MPU6050

# Functions to Read Data from the MPU6050
def read_byte(reg):
    return bus.read_byte_data(address, reg)

def read_word(reg):
    h = bus.read_byte_data(address, reg)
    l = bus.read_byte_data(address, reg + 1)
    return (h << 8) + l

def read_word_2c(reg):
    val = read_word(reg)
    if (val >= 0x8000):
        return -((65535 - val) + 1)
    else:
        return val

def dist(a, b):
    return math.sqrt((a * a) + (b * b))

def get_y_rotation(x, y, z):
    radians = math.atan2(x, dist(y, z))
    return -math.degrees(radians)

def get_x_rotation(x, y, z):
    radians = math.atan2(y, dist(x, z))
    return math.degrees(radians)

# Wake up the MPU6050 (Start I2C Communication)
try:
    bus.write_byte_data(address, power_mgmt_1, 0)
    print("MPU6050 Initialized Successfully")
except OSError:
    print("Error: Unable to communicate with the MPU6050. Check your wiring or I2C setup.")

# Main loop to read sensor data and control servos
try:
    while True:
        # Reading accelerometer data (X, Y, Z axis)
        acceleration_x = read_word_2c(0x3b)
        acceleration_y = read_word_2c(0x3d)
        acceleration_z = read_word_2c(0x3f)

        # Scale the accelerometer data
        acceleration_x_scaled = acceleration_x / 16384.0
        acceleration_y_scaled = acceleration_y / 16384.0
        acceleration_z_scaled = acceleration_z / 16384.0

        # Get X and Y rotations (used for servo control)
        x_rotation = get_x_rotation(acceleration_x_scaled, acceleration_y_scaled, acceleration_z_scaled)
        y_rotation = get_y_rotation(acceleration_x_scaled, acceleration_y_scaled, acceleration_z_scaled)

        # Map X rotation to servo1 (X axis movement)
        servo1_position = 7.5 + (x_rotation / 90.0) * 5.0  # Scale based on range
        servo1_position = max(2.5, min(12.5, servo1_position))  # Constrain to valid range
        servo1.ChangeDutyCycle(servo1_position)

        # Map Y rotation to servo2 (Y axis movement)
        servo2_position = 7.5 + (y_rotation / 90.0) * 5.0  # Scale based on range
        servo2_position = max(2.5, min(12.5, servo2_position))  # Constrain to valid range
        servo2.ChangeDutyCycle(servo2_position)

        # Print values for debugging (optional)
        print(f"X Rotation: {x_rotation:.2f}, Y Rotation: {y_rotation:.2f}")
        time.sleep(0.1)

except KeyboardInterrupt:
    print("Program terminated.")
    servo1.stop()
    servo2.stop()
    GPIO.cleanup()
