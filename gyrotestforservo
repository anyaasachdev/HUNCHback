import RPi.GPIO as GPIO
import smbus
import math
from time import sleep

# GPIO setup
GPIO.setmode(GPIO.BOARD)
GPIO.setup(7, GPIO.OUT)  # X servo pin
GPIO.setup(13, GPIO.OUT)  # Y servo pin
servo1 = GPIO.PWM(7, 50)  # 50Hz for X servo
servo2 = GPIO.PWM(13, 50)  # 50Hz for Y servo
servo1.start(7.5)  # Neutral position
servo2.start(7.5)  # Neutral position

# I2C setup for MPU6050
bus = smbus.SMBus(1)
address = 0x68
bus.write_byte_data(address, 0x6b, 0)

# Helper functions
def read_word(reg):
    high = bus.read_byte_data(address, reg)
    low = bus.read_byte_data(address, reg + 1)
    return (high << 8) + low

def read_word_2c(reg):
    val = read_word(reg)
    return val - 65536 if val >= 0x8000 else val

def dist(a, b):
    return math.sqrt(a * a + b * b)

def get_x_rotation(x, y, z):
    radians = math.atan2(y, dist(x, z))
    return math.degrees(radians)

def get_y_rotation(x, y, z):
    radians = math.atan2(x, dist(y, z))
    return -math.degrees(radians)

def map_rotation_to_duty(rotation, min_angle=-90, max_angle=90):
    rotation = max(min(rotation, max_angle), min_angle)  # Clamp within bounds
    return (rotation - min_angle) * (12.5 - 2.5) / (max_angle - min_angle) + 2.5

# Main loop
try:
    while True:
        # Read accelerometer data
        accel_x = read_word_2c(0x3b)
        accel_y = read_word_2c(0x3d)
        accel_z = read_word_2c(0x3f)

        # Scale accelerometer data
        accel_x_scaled = accel_x / 16384.0
        accel_y_scaled = accel_y / 16384.0
        accel_z_scaled = accel_z / 16384.0

        # Get rotations
        x_rotation = get_x_rotation(accel_x_scaled, accel_y_scaled, accel_z_scaled)
        y_rotation = get_y_rotation(accel_x_scaled, accel_y_scaled, accel_z_scaled)

        # Debug prints
        print(f"X Rotation: {x_rotation}, Y Rotation: {y_rotation}")

        # Map rotations to servo duty cycles
        servo1_duty = map_rotation_to_duty(x_rotation)
        servo2_duty = map_rotation_to_duty(y_rotation)

        # Debug duty cycles
        print(f"Servo1 Duty: {servo1_duty}, Servo2 Duty: {servo2_duty}")

        # Apply to servos
        servo1.ChangeDutyCycle(servo1_duty)
        servo2.ChangeDutyCycle(servo2_duty)

        sleep(0.1)

except KeyboardInterrupt:
    # Clean up on exit
    servo1.stop()
    servo2.stop()
    GPIO.cleanup()
